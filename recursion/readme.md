## Recursion
---
* 모든 재귀 함수는 반복문(iteration)으로 변경 가능

* 그 역도 성립함. 즉, 모든 반복문 역시 재귀 함수로 변경 가능

* 재귀 함수는 복잡한 알고리즘을 단순하고 알기쉽게 표현하는 것을 가능하게 함

* 하지만 함수 호출에 따른 오버헤드가 있음(매개변수 전달, 스택에 액티베이션 생성) -> 속도 느려짐 (반복문이 재귀 함수보다 더 성능이 좋은 경우가 많다)

* 모든 프로그램은 호출 스택에 할당하는 공간이 정해져있기 떄문에 횟수에 제한 있다 -> stack over flow

* 무한루프에 빠지지 않기 위해선?
 1.  Base case : 적어도 하나의 recursion에 빠지지 않는 경우가 존재해야한다
 2. Recursive case : recursion을 반복하다 보면 base case로 수렴해야 한다

* 스택의 가장 상단에 현재 호출하고 있는 함수가 위치함. 그 아래에 있는 함수들은 각각의 매개변수를 저장하고 정지 상태로 있음(메모리 소비 많다)...오버 헤드 발생

* 스택에 데이터를 많이 쌓을수록 사용하는 메모리는 증가한다


### recursion1.js

> 1 ~ n까지 합
>
> 팩토리얼
>
> x의 n승
>
> 피보나치
>
> 최대공약수 방법 1
>
> 최대공약수 방법 2
>
> 조합(combination)


### recursion2.js

> 문자열 출력
>
> 문자열 역순으로 출력
>
> 10진수를 2진수로 만들기
>
> 배열의 원소의 합 구하기

### recursion3.js

> 순차 탐색
>
> 최대값 구하기
>
> 2진 탐색

### [하노이탑](./hanoi)

### [미로찾기](./maze)

### [counting cells in a blob](./countingCells)

### [n-queens](./n-queens)

### 중복 순열, 순열, 조합, 중복 조합 익혀 두기

### 주의 !

1. func() 함수에서 a배열에 값 집어 넣을 때 if문 위치 중요하다 -> if문에 a[dep]에 값이 안들어가져 있는 상태일 때가 종종 있다

  ex) division.java

2. func() 함수에서 모든 경우의 수를 만든 다음 if문으로 출력만 제한하는 경우

  ex) 숫자 만들기 문제에서 합이 0인 경우의 식만을 출력하라고 하는 경우

  func() 함수에서 모든 경우의 수를 만들기 전에 for문에서 a배열을 만들 때 if문으로 커팅 하는 경우

  ex) 좋은 수열 문제

  두 경우를 구분하는 기준은, 끝까지 a배열에 값을 넣어보지 않아도 판별이 되는 경우에는 후자. 다 넣어보고 판별해야 하는 경우는 전자

3. a배열에 값을 집어 넣을 때, 큰 값 부터 넣는 경우엔 for문을 돌 때 마지막 값부터 넣는다. base case에 도착해서는 a배열을 처음부터 꺼낸다

  ex) 부등호 문제

  작은 값 부터 넣는 경우엔 for문 돌 때 처음 값부터 넣고 base case에서는 마찬가지로 a배열을 처음부터 꺼낸다


4. 순열에서 check 배열(or visited 배열)의 크기는 a배열의 크기와 다르다. a배열의 크기는 depth만큼. check 배열의 크기는 node 개수 만큼
