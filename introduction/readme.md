## Introduction
---

> 알고리즘이란?
>
> 어떤 명령을 하기 위한 집합

### Big O notation


* 알고리즘은 시간이 아니라 연산 휫수가 어떻게 증가하는지로 측정하는데, 이 때 Big O 표기법을 사용한다

* Big O 표기법은 최악의 경우에 대한 것이다 (한 번에 찾는 경우가 있지만 최선의 경우라 할지라도 Big O 표기법은 달라지지 않는다)

* 상수는 무시한다

* 순서 (위로 갈수록 빠르다)

  O(log n) - 이진 탐색

  O(n) - 단순 탐색

  O(n * log n) - 퀵 정렬

  O(n^2) - 선택 정렬

  O(n!) - 외판원 문제

![chart](./chart.png)

### array VS linked list

list에는 array와 linked list가 존재한다

배열은 원소가 순서대로 저장되기 때문에 원소의 크기 만큼 메모리(공간)가 확보 되어 있어야 한다. 하지만 연결 리스트는 다음 메모리의 주소를 앞의 노드에서 이미 알고 있기 때문에 어떤 메모리든 비어 있는 곳을 사용하고 그 주소를 앞의 노드에 저장해두면 된다(사용성 좋음. 따라서 다음 노드의 주소와 현재 값이 현재 노드에 저장되어 있음). 배열이 리스트보다 좋은 점은 원소를 읽을 때다. 배열의 경우 원소가 순차적으로 놓여 있기 때문에 인덱스 번호만 알면 원소를 읽을 수 있지만(임의 접근), 리스트의 경우 처음 원소에서 해당 원소까지 순서대로 이동해야만 읽을 수 있다(순차 접근)

흔히 배열은 삽입 및 삭제 시에 시간 복잡도가 O(n)이고, 연결 리스트는 O(1)이라고 하는데 엄밀히 하면 그렇지 않다. 왜냐하면 연결 리스트 역시 삽입 및 삭제하려는 인덱스에 도달하기 위해서는 O(n)만큼의 시간이 필요하기 때문이다. 만약 연결 리스트의 head(맨 첫번째 노드)에 삽입하거나 삭제한다면 O(1)이 될 수 있다. 또한 원하는 노드를 가르키는 포인터가 별도로 존재한다면 이 역시 O(1)이 될 수 있다

참조

https://m.blog.naver.com/PostView.nhn?blogId=kks227&logNo=220781402507&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F
